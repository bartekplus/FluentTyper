import {
  SUPPORTED_LANGUAGES,
  LANG_ADDITIONAL_SEPERATOR_REGEX,
} from "./lang.js";

import { DATE_TIME_VARIABLES } from "./variables.js";

const Spacing = Object.freeze({
  INSERT_SPACE: Symbol("INSERT_SPACE"),
  REMOVE_SPACE: Symbol("REMOVE_SPACE"),
  NO_CHANGE: Symbol("NO_CHANGE"),
});

const NEW_SENTENCE_CHARS = [".", "?", "!"];
const SPACING_RULES = {
  ".": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  ",": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  "]": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  ")": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  "}": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  ">": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  "!": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  ":": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  ";": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  "?": { spaceBefore: Spacing.REMOVE_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  "[": { spaceBefore: Spacing.INSERT_SPACE, spaceAfter: Spacing.REMOVE_SPACE },
  "(": { spaceBefore: Spacing.INSERT_SPACE, spaceAfter: Spacing.REMOVE_SPACE },
  "{": { spaceBefore: Spacing.INSERT_SPACE, spaceAfter: Spacing.REMOVE_SPACE },
  "<": { spaceBefore: Spacing.INSERT_SPACE, spaceAfter: Spacing.REMOVE_SPACE },
  "/": { spaceBefore: Spacing.INSERT_SPACE, spaceAfter: Spacing.INSERT_SPACE },
  // TODO: Validate spacing rules for below symbols
  "—": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "–": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "-": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "’": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "*": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "+": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
  "=": { spaceBefore: Spacing.NO_CHANGE, spaceAfter: Spacing.NO_CHANGE },
};
const SPACE_CHARS = ["\xA0", " "];
const PAST_WORDS_COUNT = 5;
const SUGGESTION_COUNT = 5;
const MIN_WORD_LENGTH_TO_PREDICT = 1;

const Capitalization = Object.freeze({
  FirstLetter: Symbol("letter"),
  WholeWord: Symbol("word"),
  None: Symbol("none"),
});

class PresageHandler {
  /**
   * Creates a new instance of the PresageManager class
   * @constructor
   * @param {Object} Module - The module object containing the Presage and PresageCallback classes
   */
  constructor(Module) {
    // Set the module object
    this.Module = Module;

    // Initialize variables
    this.lastPrediction = {}; // Last presage prediction per language
    this.libPresage = {}; // libPresage module per language
    this.libPresageCallback = {}; // PresageCallback implementation per language
    this.libPresageCallbackImpl = {}; // PresageCallback implementation object per language
    this.numSuggestions = SUGGESTION_COUNT; // Number of suggestions generated by presage engine
    this.minWordLengthToPredict = MIN_WORD_LENGTH_TO_PREDICT; // Minimum characters typed by user to start prediction
    this.predictNextWordAfterSeparatorChar = MIN_WORD_LENGTH_TO_PREDICT === 0; // Predict next word after separator char
    this.insertSpaceAfterAutocomplete = true; // Automatically insert space after autocomplete
    this.autoCapitalize = true; // Capitalize the first word of each sentence
    this.applySpacingRules = false; // Apply spacing rules
    this.textExpansions = []; // Text expander config
    this.variableExpansion = false; // Variable expansion support
    this.timeFormat = ""; // Custom time format
    this.dateFormat = ""; // Custom time format

    // Precompiled regular expressions
    this.separatorCharRegEx =
      /\s+|!|"|#|\$|%|&|\(|\)|\*|\+|,|-|\.|\/|:|;|<|=|>|\?|@|\[|\\|\]|\^|_|`|{|\||}|~/;
    this.keepPredCharRegEx = /\[|\(|{|<|\/|-|\*|\+|=|"/; // Subset of separatorCharRegEx - keep predicting after those chars
    this.whiteSpaceRegEx = /\s+/;
    this.whiteSpaceRegExExcludeNewLine = /[^\S\r\n]+/;
    this.letterRegEx = /^\p{L}/u;

    // Initialize Presage and PresageCallback objects for each supported language
    for (const [lang] of Object.entries(SUPPORTED_LANGUAGES)) {
      if (lang === "auto_detect") continue;
      try {
        // Initialize the lastPrediction object for the language
        this.lastPrediction[lang] = { pastStream: "", predictions: [] };

        // Initialize the libPresageCallback object for the language
        this.libPresageCallback[lang] = {
          pastStream: "",

          /**
           * Gets the past stream for the PresageCallback object
           * @returns {string} The past stream
           */
          get_past_stream: function () {
            return this.pastStream;
          },

          /**
           * Gets the future stream for the PresageCallback object
           * @returns {string} An empty string
           */
          get_future_stream: function () {
            return "";
          },
        };

        // Implement the libPresageCallback object for the language
        this.libPresageCallbackImpl[lang] =
          this.Module.PresageCallback.implement(this.libPresageCallback[lang]);

        // Initialize the libPresage object for the language
        this.libPresage[lang] = new this.Module.Presage(
          this.libPresageCallbackImpl[lang],
          "resources_js/" + lang + "/presage.xml"
        );
      } catch (error) {
        console.log(
          "Failed to create Presage instance for %s language: %s",
          lang,
          error
        );
      }
    }
  }

  /**
   * Sets up the text expansions by writing them to a text file and configuring
   * abbreviation expansion predictor for each libPresage instance
   */
  setupTextExpansions() {
    // Check if there are any text expansions to set up
    if (!this.textExpansions) {
      return;
    }

    // Construct a string with each text expansion formatted as a tab-separated entry and newline-separated row
    let textExpansionsStr = "";
    this.textExpansions.forEach((textExpansion) => {
      const jsonObj = JSON.stringify(textExpansion[1]);
      textExpansionsStr += `${textExpansion[0].toLowerCase()}\t${jsonObj}\n`;
    });

    // Write the text expansions to a text file
    this.Module.FS.writeFile("/textExpansions.txt", textExpansionsStr);

    // Configure abbreviation expansion predictor for each libPresage instance
    for (const [, libPresage] of Object.entries(this.libPresage)) {
      libPresage.config(
        "Presage.Predictors.DefaultAbbreviationExpansionPredictor.ABBREVIATIONS",
        "/textExpansions.txt"
      );
    }
  }

  /**
    Sets the configuration for the Presage engine.
    @param {number} numSuggestions - The number of suggestions to generate.
    @param {number} minWordLengthToPredict - The minimum number of characters that the user must type before the engine starts predicting.
    @param {boolean} insertSpaceAfterAutocomplete - Whether to insert a space after the autocomplete suggestion.
    @param {boolean} autoCapitalize - Whether to capitalize the first word of each sentence.
    @param {boolean} applySpacingRules - Whether to apply spacing rules.
    @param {Array} textExpansions - An array of text expansions to configure the engine.
    */
  setConfig(
    numSuggestions,
    minWordLengthToPredict,
    insertSpaceAfterAutocomplete,
    autoCapitalize,
    applySpacingRules,
    textExpansions,
    variableExpansion,
    timeFormat,
    dateFormat
  ) {
    this.numSuggestions = numSuggestions;
    this.minWordLengthToPredict = minWordLengthToPredict;
    this.predictNextWordAfterSeparatorChar = minWordLengthToPredict === 0;
    this.insertSpaceAfterAutocomplete = insertSpaceAfterAutocomplete;
    this.autoCapitalize = autoCapitalize;
    this.applySpacingRules = applySpacingRules;
    this.textExpansions = textExpansions;
    this.variableExpansion = variableExpansion;
    this.timeFormat = timeFormat;
    this.dateFormat = dateFormat;
    this.setupTextExpansions();
    for (const [, libPresage] of Object.entries(this.libPresage)) {
      libPresage.config(
        "Presage.Selector.SUGGESTIONS",
        this.numSuggestions.toString()
      );
    }
  }

  /**
   * Check if a given character is a whitespace.
   * @param {string} character - The character to be checked.
   * @param {boolean} matchNewLine - Optional parameter indicating whether to match newline characters as well (default is true).
   * @returns {boolean} True if the character is a whitespace, false otherwise.
   */
  isWhiteSpace(character, matchNewLine = true) {
    // return true if character matches the whitespace regular expression based on the matchNewLine parameter
    if (matchNewLine) {
      return this.whiteSpaceRegEx.test(character);
    } else {
      return this.whiteSpaceRegExExcludeNewLine.test(character);
    }
  }

  /**
   * Check if a given character is a letter.
   * @param {string} character - The character to be checked.
   * @returns {boolean} True if the character is a letter, false otherwise.
   */
  isLetter(character) {
    // return true if character matches the letter regular expression
    return this.letterRegEx.test(character);
  }

  /**
   * Count the number of digits in a given string.
   * @param {string} str - The string to be counted.
   * @returns {number} The number of digits in the string.
   */
  countDigits(str) {
    // replace all non-digit characters with an empty string and return the length of the resulting string
    return str.replace(/[^0-9]/g, "").length;
  }

  /**
   * Check if a given string is a number.
   * @param {string} str - The string to be checked.
   * @returns {boolean} True if the string is a number, false otherwise.
   */
  isNumber(str) {
    // return true if the string is a valid number or if it contains at least two digits
    return (
      (!isNaN(str) && !isNaN(parseFloat(str))) || this.countDigits(str) > 1
    );
  }

  parseStringTemplate(str, obj) {
    const parts = str.split(/\$\{(?!\d)[\wæøåÆØÅ]*\}/);
    const args = str.match(/[^{}]+(?=})/g) || [];
    const parameters = args.map(
      (argument) =>
        obj[argument] ||
        (obj[argument] === undefined ? "${" + argument + "}" : obj[argument])
    );
    return String.raw({ raw: parts }, ...parameters);
  }

  /**
   * Expand template variables
   *
   * @param {string} lang The language to use for prediction.
   * @returns {Object} An expanded template variables
   */
  getExpandedVariables(lang) {
    const expandedTemplateVariables = {};

    if (this.variableExpansion === false) {
      return expandedTemplateVariables;
    }

    expandedTemplateVariables["time"] = DATE_TIME_VARIABLES.time(
      lang,
      this.timeFormat
    );
    expandedTemplateVariables["date"] = DATE_TIME_VARIABLES.date(
      lang,
      this.dateFormat
    );
    return expandedTemplateVariables;
  }

  /**
   * Remove the previous sentence from a given array of words.
   * @param {string[]} wordArrayOrig - The original array of words to be modified.
   * @returns {object} An object containing the modified array of words and a boolean value indicating whether a new sentence was found.
   */
  removePrevSentence(wordArrayOrig) {
    // set initial variables
    let newSentence = false;
    let wordArray = wordArrayOrig.slice(); // make a copy of the original array

    // iterate backwards through the array to find the start of the previous sentence
    for (let index = wordArray.length - 1; index >= 0; index--) {
      const element = wordArray[index];

      // check for characters that indicate the start of a new sentence
      if (
        // check for "." in the current element
        NEW_SENTENCE_CHARS.includes(element) ||
        // check for "WORD." in the current element
        NEW_SENTENCE_CHARS.includes(element.slice(-1))
      ) {
        // if a new sentence is found, slice the array from the start of the new sentence
        wordArray = wordArray.splice(index + 1);
        newSentence = true;
        break;
      }
    }

    // return the modified array and a boolean indicating whether a new sentence was found
    return { wordArray, newSentence };
  }

  /**
   * Checks if auto capitalization should be applied based on the input tokens and punctuation marks.
   * @param {string[]} tokensArray - The array of input tokens.
   * @param {boolean} newSentence - Indicates if the input includes a new sentence.
   * @param {boolean} endsWithSpace - Indicates if the input ends with a whitespace.
   * @returns {Capitalization} The type of capitalization to be applied.
   */
  checkAutoCapitalize(tokensArray, newSentence, endsWithSpace) {
    const lastWord = tokensArray.length
      ? tokensArray[tokensArray.length - 1]
      : "";
    const firstCharacterOfLastWord = lastWord.slice(0, 1);

    // Check for whole word capitalization
    // when the input meets the conditions
    // * doesn't end with whitespace
    // * first letter of last word is uppercase
    // * word is at least 2 characters
    // * eg.  " XYZ"
    if (
      !endsWithSpace &&
      lastWord &&
      lastWord.length > 1 &&
      lastWord === lastWord.toUpperCase()
    )
      return Capitalization.WholeWord;

    // Check for first letter capitalization
    // when the input meets the conditions
    // * doesn't end with whitespace
    // * first letter of last word is uppercase
    // * eg.  " Xyz"
    if (
      !endsWithSpace &&
      this.isLetter(firstCharacterOfLastWord) &&
      firstCharacterOfLastWord === firstCharacterOfLastWord.toUpperCase()
    )
      return Capitalization.FirstLetter;

    // Check for first letter capitalization
    // when auto capitalization is enabled and the input meets the conditions
    // * it includes one of NEW_SENTENCE_CHARS and there is exactly one word after it and
    //   last word doesn't end with whitespace
    // * or it includes one of NEW_SENTENCE_CHARS and there are no words after it
    //   and it ends with whitespace
    // * eg.  "xyz. xyz" or "xyz. "
    if (
      this.autoCapitalize &&
      newSentence &&
      ((!endsWithSpace && tokensArray.length === 1) ||
        (endsWithSpace && tokensArray.length === 0))
    )
      return Capitalization.FirstLetter;

    // If none of the above cases apply, do not apply capitalization
    return Capitalization.None;
  }

  /**
  Checks if prediction should be run based on the last word and whether it ends with space
  @param {string} lastWord - The last word in the input string
  @param {boolean} endsWithSpace - Indicates if the input string ends with a space character
  @returns {boolean} - Whether or not to run prediction
  */
  checkDoPrediction(lastWord, endsWithSpace) {
    // If the number of suggestions is set to zero, disable prediction
    if (this.numSuggestions <= 0) return false;
    // Don't run prediction on numbers
    if (!endsWithSpace && this.isNumber(lastWord)) return false;

    // If the input ends with whitespace and the minimum word length to start prediction is not set to 0, disable prediction
    if (endsWithSpace && !this.predictNextWordAfterSeparatorChar) return false;

    // If the last word is too short to start prediction, disable prediction
    if (!endsWithSpace && lastWord.length < this.minWordLengthToPredict)
      return false;

    // If the last word includes a separator character, disable prediction
    if (
      !endsWithSpace &&
      (lastWord.match(this.separatorCharRegEx) || []).length !==
        (lastWord.match(this.keepPredCharRegEx) || []).length
    )
      return false;

    return true;
  }

  /**
   * Processes input for prediction by modifying the input string and setting
   * flags to indicate whether to perform auto-capitalization and prediction.
   *
   * @param {string} predictionInput - The input string to process.
   * @param {string} language - The language of the input string.
   * @returns {object} - An object containing the processed input string, last word,
   *                     a flag indicating whether to perform prediction, and
   *                     a flag indicating whether to perform auto-capitalization.
   */
  processInput(predictionInput, language) {
    // Check if the input string is valid
    if (
      typeof predictionInput !== "string" &&
      !(predictionInput instanceof String)
    ) {
      return { predictionInput, doPrediction: false, doCapitalize: false };
    }
    // Check if predictionInput ends with a space
    const endsWithSpace = predictionInput !== predictionInput.trimEnd();

    // Workaround; Lang specific separator chars should be handled by Presage
    // Replace additional separators with spaces, if necessary
    const additionalSeparatorRegex = LANG_ADDITIONAL_SEPERATOR_REGEX[language];
    if (additionalSeparatorRegex) {
      predictionInput = predictionInput.replace(additionalSeparatorRegex, " ");
    }

    // Split the input string into an array of words, removing whitespace and empty strings
    const lastWordsArray = predictionInput
      .split(this.whiteSpaceRegEx) // Split on any whitespace
      .filter(function (e) {
        return e.trim(); // filter empty elements
      })
      .splice(-PAST_WORDS_COUNT); // Get last PAST_WORDS_COUNT words

    // Remove previous sentence from lastWordsArray and get the new sentence
    const { wordArray, newSentence } = this.removePrevSentence(lastWordsArray);

    // Join the remaining words in wordArray and add a space if endsWithSpace is true
    predictionInput = wordArray.join(" ") + (endsWithSpace ? " " : "");

    // Get the last word from lastWordsArray and remove any keepPredCharRegEx characters
    let lastWord = lastWordsArray.length
      ? lastWordsArray[lastWordsArray.length - 1]
      : "";
    lastWord =
      lastWord
        .split(this.keepPredCharRegEx) // Split on keepPredCharRegEx
        .filter(function (e) {
          return e.trim(); // filter empty elements
        })
        .pop() || "";

    // Check if auto-capitalization should be performed
    const doCapitalize = this.checkAutoCapitalize(
      wordArray,
      newSentence,
      endsWithSpace
    );

    // Check if prediction should be performed
    const doPrediction = this.checkDoPrediction(lastWord, endsWithSpace);

    // Return an object with the processed input string, last word and the flags for auto-capitalization and prediction
    return { predictionInput, lastWord, doPrediction, doCapitalize };
  }

  /**
   * Handles spacing rules based on the last character in the input string.
   * @param {string} inputStr - The input string to apply spacing rules to.
   * @returns {object} An object containing the updated text and its length, or null if no changes were made.
   */
  spacingRulesHandler(inputStr) {
    // Return null if inputStr is falsy.
    if (!inputStr) {
      return null;
    }

    const { length } = inputStr;

    // Get the last three characters from inputStr.
    const lastChar = inputStr[length - 1];
    const lastCharMin1 = inputStr[length - 2];
    const lastCharMin2 = inputStr[length - 3];

    // Return null if lastCharMin1 is falsy.
    if (!lastCharMin1) {
      return null;
    }

    // Return null if lastChar is not a key in SPACING_RULES.
    if (!SPACING_RULES[lastChar]) {
      return null;
    }

    // Return null if lastCharMin2 is a space character.
    if (SPACE_CHARS.includes(lastCharMin2)) {
      return null;
    }

    // Return null if the spacing before lastChar should insert a space, but lastCharMin1 is already a space character.
    if (
      (SPACING_RULES[lastChar].spaceBefore === Spacing.INSERT_SPACE) ===
      SPACE_CHARS.includes(lastCharMin1)
    ) {
      return null;
    }

    // Construct the updated text based on the spacing rules.
    const insertSpaceBefore =
      SPACING_RULES[lastChar].spaceBefore === Spacing.INSERT_SPACE;
    const insertSpaceAfter =
      this.insertSpaceAfterAutocomplete &&
      SPACING_RULES[lastChar].spaceAfter === Spacing.INSERT_SPACE;
    const text = `${insertSpaceBefore ? "\xA0" : ""}${lastChar}${
      insertSpaceAfter ? "\xA0" : ""
    }`;

    // Return null if txt is the same as lastChar.
    if (text === lastChar) {
      return null;
    }

    // Return an object containing the updated text and its length.
    return {
      text,
      length: 2 - Number(insertSpaceBefore),
    };
  }

  /**
   * Handles predictions for a given input and language.
   *
   * @param {string} predictionInput The input to predict on.
   * @param {string} lang The language to use for prediction.
   * @returns {Array} An array of predicted results.
   */
  doPredictionHandler(predictionInput, lang) {
    // If the input is the same as the previous prediction input, return the previous prediction results
    if (predictionInput === this.lastPrediction[lang].pastStream) {
      return this.lastPrediction[lang].predictions.slice();
    }

    // Perform prediction
    this.libPresageCallback[lang].pastStream = predictionInput;
    const predictions = [];
    const predictionsNative = this.libPresage[lang].predictWithProbability();

    const expandedTemplateVariables = this.getExpandedVariables(lang);

    // Loop through the predicted results and add them to the predictions array
    for (let i = 0; i < predictionsNative.size(); i++) {
      const result = predictionsNative.get(i);
      let text = null;
      try {
        text = JSON.parse(result.prediction);
      } catch (error) {
        text = result.prediction;
      }

      if (text) {
        text = this.parseStringTemplate(text, expandedTemplateVariables);
        predictions.push(text);
      }
      //result.probability
    }

    // Update the last prediction with the current input and results
    this.lastPrediction[lang] = {
      pastStream: predictionInput,
      predictions: predictions.slice(),
    };

    // Return the predicted results
    return predictions;
  }

  /**
   * Runs prediction for a given input text, next character and language.
   *
   * @param {string} text The input text to predict on.
   * @param {string} nextChar The next character after the input text.
   * @param {string} lang The language to use for prediction.
   * @returns {Object} An object containing predictions and a boolean indicating if a force replacement is needed.
   */
  runPrediction(text, nextChar, lang) {
    let predictions = [];
    let forceReplace = null;

    // Process the input text to get the prediction input, prediction flag and capitalization flag
    const { predictionInput, doPrediction, doCapitalize } = this.processInput(
      text,
      lang
    );

    // Apply spacing rules if necessary
    if (this.applySpacingRules) {
      forceReplace = this.spacingRulesHandler(text);
    }

    // If the Presage library for the given language does not exist, do nothing and return empty predictions
    if (!this.libPresage[lang]) {
      // Do nothing, reply with empty predictions
    }
    // If forceReplace is not set and prediction is necessary, perform the prediction
    else if (!forceReplace && doPrediction) {
      predictions = this.doPredictionHandler(predictionInput, lang);
    }

    // If insertSpaceAfterAutocomplete is true, add a space after each prediction if necessary
    if (this.insertSpaceAfterAutocomplete) {
      if (
        !this.isWhiteSpace(nextChar, false) &&
        (!(nextChar in SPACING_RULES) ||
          SPACING_RULES[nextChar].spaceBefore === Spacing.INSERT_SPACE)
      ) {
        predictions = predictions.map((pred) => `${pred}\xA0`);
      }
    }

    // Depending on the capitalization flag, modify the predictions accordingly
    switch (doCapitalize) {
      case Capitalization.FirstLetter:
        predictions = predictions.map(
          (pred) => pred.charAt(0).toUpperCase() + pred.slice(1)
        );
        break;
      case Capitalization.WholeWord:
        predictions = predictions.map((pred) => pred.toUpperCase());
        break;
      case Capitalization.None:
      default:
    }

    // Return the predictions and forceReplace flag
    return { predictions, forceReplace };
  }
}

export { PresageHandler };
