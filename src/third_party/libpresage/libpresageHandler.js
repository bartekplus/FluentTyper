"use strict";

let presageHandler = null;

function initlizePresageHandler() {
  presageHandler = new PresageHandler();
}

let Module = {
  onRuntimeInitialized: function () {
    setTimeout(initlizePresageHandler, 0);
  },
};

const NEW_SENTENCE_CHARS = [".", "?", "!"];
const SUPPORTED_LANGUAGES = ["en"];
class PresageHandler {
  constructor() {
    // last presage prediction per lang
    this.lastPrediction = {};
    // presage timeouts per tabId and frameId
    this.predictionTimeouts = {};
    // libPresage module
    this.libPresage = {};
    this.libPresageCallback = {};
    this.libPresageCallbackImpl = {};
    // Number of suggestion generated by presage engine
    this.numSuggestions = 5;
    // Minimum characters typed by user to start prediction
    this.minWordLenghtToPredict = 1;
    // Predict next word after whitespace
    this.predictNextWordAfterWhiteSpace = true;
    // Automatically insert space after autocomplete
    this.insertSpaceAfterAutocomplete = true;
    // Capitalize the first word of each sentence
    this.autoCapitalize = true;
    //Precompiled regular expressions
    this.whiteSpaceRegEx = RegExp(/\s+/);
    this.letterRegEx = RegExp(/^\p{L}/, "u");
    // Attach event listener
    window.addEventListener("message", this.messageHandler.bind(this));
    SUPPORTED_LANGUAGES.forEach((lang) => {
      this.lastPrediction[lang] = { pastStream: null, predictions: [] };
      this.libPresageCallback[lang] = {
        pastStream: "",

        get_past_stream: function () {
          return this.pastStream;
        },

        get_future_stream: function () {
          return "";
        },
      };
      this.libPresageCallbackImpl[lang] = Module.PresageCallback.implement(
        this.libPresageCallback[lang]
      );
      this.libPresage[lang] = new Module.Presage(
        this.libPresageCallbackImpl[lang],
        "resources_js/presage_" + lang + ".xml"
      );
    });
  }

  messageHandler(event) {
    const command = event.data.command;
    const context = event.data.context;
    switch (command) {
      case "backgroundPagePredictReq": {
        const tabId = event.data.context.tabId;
        const frameId = event.data.context.frameId;
        if (!this.predictionTimeouts[tabId]) {
          this.predictionTimeouts[tabId] = {};
        } else if (this.predictionTimeouts[tabId][frameId]) {
          clearTimeout(this.predictionTimeouts[tabId][frameId]);
        }
        this.predictionTimeouts[tabId][frameId] = setTimeout(
          this.runPrediction.bind(this, event),
          0
        );
        break;
      }
      case "backgroundPageSetConfig": {
        this.setConfig(
          context.numSuggestions,
          context.minWordLenghtToPredict,
          context.predictNextWordAfterWhiteSpace,
          context.insertSpaceAfterAutocomplete,
          context.autoCapitalize
        );
        break;
      }
      default:
        console.log("Unknown message:");
        console.log(event);
    }
  }

  setConfig(
    numSuggestions,
    minWordLenghtToPredict,
    predictNextWordAfterWhiteSpace,
    insertSpaceAfterAutocomplete,
    autoCapitalize
  ) {
    this.numSuggestions = numSuggestions;
    this.minWordLenghtToPredict = minWordLenghtToPredict;
    this.predictNextWordAfterWhiteSpace = predictNextWordAfterWhiteSpace;
    this.insertSpaceAfterAutocomplete = insertSpaceAfterAutocomplete;
    this.autoCapitalize = autoCapitalize;

    for (const [lang, libPresage] of Object.entries(this.libPresage)) {
      libPresage.config(
        "Presage.Selector.SUGGESTIONS",
        this.numSuggestions.toString()
      );
    }
  }

  getLastWordLenght(str) {
    const wordArray = str.split(this.whiteSpaceRegEx);
    if (wordArray.length) {
      return wordArray[wordArray.length - 1].length;
    }

    return 0;
  }

  isLetter(character) {
    return this.letterRegEx.test(character);
  }

  checkInput(predictionInput) {
    const isLastCharWhitespace = predictionInput !== predictionInput.trimEnd();
    const lastWordLenght = this.getLastWordLenght(predictionInput);
    const isLastCharLetter = this.isLetter(
      predictionInput[predictionInput.length - 1]
    );

    if (this.predictNextWordAfterWhiteSpace && isLastCharWhitespace) {
      return true;
    }
    if (isLastCharLetter && lastWordLenght >= this.minWordLenghtToPredict) {
      return true;
    }

    return false;
  }

  convertString(str) {
    if (typeof str === "string" || str instanceof String) {
      // Check if string end with whitespace
      const endWithSpace = str !== str.trimEnd();
      // Get 3 last words and filter empty
      let wordArray = str
        .split(this.whiteSpaceRegEx) // Split on any whitespace
        .filter(function (e) {
          return e.trim(); // filter empty elements
        })
        .splice(-3); // Get last 3 words
      // Check for new sentence start
      for (let index = 0; index < wordArray.length; index++) {
        const element = wordArray[index];
        // Use only words from new setence for prediction
        if (NEW_SENTENCE_CHARS.includes(element)) {
          wordArray = wordArray.splice(index);
          break;
        }
        if (NEW_SENTENCE_CHARS.includes(element.slice(-1))) {
          wordArray = wordArray.splice(index + 1);
          break;
        }
      }

      str = wordArray.join(" ");
      if (endWithSpace) {
        str += " ";
      }

      if (this.checkInput(str)) return str;
    }

    return null;
  }

  doAutoCapitalize(pastStream, predictions) {
    if (!pastStream) return predictions;
    let doCapitalize = false;
    const isLastCharWhitespace = pastStream !== pastStream.trimEnd();
    // Split past stream into words
    const lastWord = pastStream
      .split(this.whiteSpaceRegEx)
      .filter(function (e) {
        return e.trim(); // filter empty elements
      })
      .splice(-1)[0];
    const firstCharacterOfLastWord = lastWord ? lastWord[0] : " ";
    const lastCharacterOfLastWord = lastWord ? lastWord.slice(-1) : " ";
    if (
      !isLastCharWhitespace &&
      this.isLetter(firstCharacterOfLastWord) &&
      firstCharacterOfLastWord === firstCharacterOfLastWord.toUpperCase()
    ) {
      doCapitalize = true;
    } else if (NEW_SENTENCE_CHARS.includes(lastCharacterOfLastWord)) {
      doCapitalize = true;
    }
    if (doCapitalize) {
      return predictions.map(
        (pred) => pred.charAt(0).toUpperCase() + pred.slice(1)
      );
    }
    return predictions;
  }

  runPrediction(event) {
    const context = event.data.context;
    const pastStream = this.convertString(event.data.context.text);
    const message = { command: "sandBoxPredictResp", context: context };
    if (!pastStream || !this.libPresage[context.lang]) {
      // Invalid input or presage predition module not ready yet - reply with empty predictions
      message.context.predictions = [];
    } else if (pastStream === this.lastPrediction[context.lang].pastStream) {
      message.context.predictions =
        this.lastPrediction[context.lang].predictions;
    } else {
      message.context.predictions = [];
      this.libPresageCallback[context.lang].pastStream = pastStream;
      const predictionsNative = this.libPresage[context.lang].predict();
      for (let i = 0; i < predictionsNative.size(); i++) {
        message.context.predictions.push(predictionsNative.get(i));
      }
      this.lastPrediction[context.lang].pastStream = pastStream;
      this.lastPrediction[context.lang].predictions =
        message.context.predictions;
    }
    // Add space if needed
    if (this.insertSpaceAfterAutocomplete) {
      message.context.predictions = message.context.predictions.map(
        (pred) => `${pred} `
      );
    }
    // Auto capitalize if needed
    if (this.autoCapitalize) {
      message.context.predictions = this.doAutoCapitalize(
        pastStream,
        message.context.predictions
      );
    }
    this.predictionTimeouts[event.data.context.tabId][
      event.data.context.frameId
    ] = null;
    event.source.postMessage(message, event.origin);
  }
}
