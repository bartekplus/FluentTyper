"use strict";

let presageHandler = null;

function initlizePresageHandler() {
  presageHandler = new PresageHandler();
}

let Module = {
  onRuntimeInitialized: function () {
    setTimeout(initlizePresageHandler, 0);
  },
};

class PresageHandler {
  constructor(
    numSuggestions = 5,
    minWordLenghtToPredict = 1,
    predictNextWordAfterWhiteSpace = true
  ) {
    const SUPPORTED_LANGUAGES = ["en"];
    // last presage prediction per lang
    this.lastPrediction = {};
    // presage timeouts per tabId and frameId
    this.predictionTimeouts = {};
    // libPresage module
    this.libPresage = {};
    this.libPresageCallback = {};
    this.libPresageCallbackImpl = {};
    // Number of suggestion generated by presage engine
    this.numSuggestions = numSuggestions;
    // Minimum characters typed by user to start prediction
    this.minWordLenghtToPredict = minWordLenghtToPredict;
    // Indicates if new predition should be gnerated after whitespace
    this.predictNextWordAfterWhiteSpace = predictNextWordAfterWhiteSpace;
    //Precompiled regular expressions
    this.whiteSpaceRegEx = RegExp(/\s+/);
    this.letterRegEx = RegExp(/^\p{L}/, "u");
    // Attach event listener
    window.addEventListener("message", this.messageHandler.bind(this));
    SUPPORTED_LANGUAGES.forEach((lang) => {
      this.lastPrediction[lang] = { pastStream: null, predictions: [] };
      this.libPresageCallback[lang] = {
        pastStream: "",

        get_past_stream: function () {
          return this.pastStream;
        },

        get_future_stream: function () {
          return "";
        },
      };
      this.libPresageCallbackImpl[lang] = Module.PresageCallback.implement(
        this.libPresageCallback[lang]
      );
      this.libPresage[lang] = new Module.Presage(
        this.libPresageCallbackImpl[lang],
        "resources_js/presage_" + lang + ".xml"
      );
    });
  }

  messageHandler(event) {
    const command = event.data.command;
    const context = event.data.context;
    switch (command) {
      case "backgroundPagePredictReq": {
        const tabId = event.data.context.tabId;
        const frameId = event.data.context.frameId;
        if (!this.predictionTimeouts[tabId]) {
          this.predictionTimeouts[tabId] = {};
        } else if (this.predictionTimeouts[tabId][frameId]) {
          clearTimeout(this.predictionTimeouts[tabId][frameId]);
        }
        this.predictionTimeouts[tabId][frameId] = setTimeout(
          this.runPrediction.bind(this, event),
          0
        );
        break;
      }
      case "backgroundPageSetConfig": {
        this.setConfig(
          context.numSuggestions,
          context.minWordLenghtToPredict,
          context.predictNextWordAfterWhiteSpace
        );
        break;
      }
      default:
        console.log("Unknown message:");
        console.log(event);
    }
  }

  setConfig(
    numSuggestions,
    minWordLenghtToPredict,
    predictNextWordAfterWhiteSpace
  ) {
    this.numSuggestions = numSuggestions;
    this.minWordLenghtToPredict = minWordLenghtToPredict;
    this.predictNextWordAfterWhiteSpace = predictNextWordAfterWhiteSpace;

    for (const [lang, libPresage] of Object.entries(this.libPresage)) {
      libPresage.config(
        "Presage.Selector.SUGGESTIONS",
        this.numSuggestions.toString()
      );
    }
  }

  getLastWordLenght(str) {
    const wordArray = str.split(this.whiteSpaceRegEx);
    if (wordArray.length) {
      return wordArray[wordArray.length - 1].length;
    }

    return 0;
  }

  isLetter(character) {
    return this.letterRegEx.test(character);
  }

  checkInput(predictionInput) {
    const isLastCharWhitespace = predictionInput !== predictionInput.trimEnd();
    const lastWordLenght = this.getLastWordLenght(predictionInput);
    const isLastCharLetter = this.isLetter(
      predictionInput[predictionInput.length - 1]
    );

    if (this.predictNextWordAfterWhiteSpace && isLastCharWhitespace) {
      return true;
    }
    if (isLastCharLetter && lastWordLenght >= this.minWordLenghtToPredict) {
      return true;
    }

    return false;
  }

  convertString(str) {
    if (typeof str === "string" || str instanceof String) {
      // Check if string end with whitespace
      const endWithSpace = str !== str.trimEnd();
      // Get 3 last words and filter empty
      const wordArray = str
        .split(this.whiteSpaceRegEx) // Split ony any whitespace
        .filter(function (e) {
          return e.trim(); // filter empty elements
        })
        .splice(-3); // Get last 3 words
      str = wordArray.join(" ");
      if (endWithSpace) {
        str += " ";
      }

      if (this.checkInput(str)) return str;
    }

    return null;
  }

  runPrediction(event) {
    const context = event.data.context;
    const pastStream = this.convertString(event.data.context.text);
    const message = { command: "sandBoxPredictResp", context: context };
    if (!pastStream || !this.libPresage[context.lang]) {
      // Invalid input or presage predition module not ready yet - reply with empty predictions
      message.context.predictions = [];
    } else if (pastStream === this.lastPrediction[context.lang].pastStream) {
      message.context.predictions =
        this.lastPrediction[context.lang].predictions;
    } else {
      message.context.predictions = [];
      this.libPresageCallback[context.lang].pastStream = pastStream;
      const predictionsNative = this.libPresage[context.lang].predict();
      for (let i = 0; i < predictionsNative.size(); i++) {
        message.context.predictions.push(predictionsNative.get(i));
      }
      this.lastPrediction[context.lang].pastStream = pastStream;
      this.lastPrediction[context.lang].predictions =
        message.context.predictions;
    }
    this.predictionTimeouts[event.data.context.tabId][
      event.data.context.frameId
    ] = null;
    event.source.postMessage(message, event.origin);
  }
}
